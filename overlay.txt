
	// VIDEO REGION
	parameter WIDTH 	 = 550;
	parameter HEIGHT   = 380;
	parameter VIDEO_X0 = (640 - WIDTH) / 2;
	parameter VIDEO_Y0 = TEXT_Y0 + TEXT_HEIGHT + 50;	// 20 px below text
	
	wire video_region  = (iVga_x >= VIDEO_X0 & iVga_x < (VIDEO_X0 + WIDTH) &
								 iVga_y >= VIDEO_Y0 & iVga_y < (VIDEO_Y0 + HEIGHT));



module VGA_overlay (
    input               iCLK,
    input               iRST_N,
    input               iVideo_On,

    input       [10:0]  iVga_x,
    input       [10:0]  iVga_y,

    input       [9:0]   iRed,
    input       [9:0]   iGreen,
    input       [9:0]   iBlue,

    output reg  [9:0]   oRed,
    output reg  [9:0]   oGreen,
    output reg  [9:0]   oBlue
);

    // ----------------------
    // Parameters
    // New character size: 16x32 (2x scaled from 8x16)
    // ----------------------
    parameter WHITE = 10'h3FF;
    parameter BLACK = 10'h000;
    parameter CHAR_WIDTH = 16;  // Doubled from 8
    parameter CHAR_HEIGHT = 32; // Doubled from 16

    // Text strings
    localparam VIDEO_ON_TEXT = "INTRUDER";
    localparam VIDEO_OFF_TEXT = "ARMED";

    localparam VIDEO_ON_LEN  = 8;
    localparam VIDEO_OFF_LEN = 5;

    // ----------------------
    // Compute text position (centered - uses new CHAR_WIDTH and CHAR_HEIGHT)
    // ----------------------
    wire [10:0] text_x0_on  = (640 - (VIDEO_ON_LEN * CHAR_WIDTH)) / 2;
    wire [10:0] text_y0_on  = 25;

    wire [10:0] text_x0_off = (640 - (VIDEO_OFF_LEN * CHAR_WIDTH)) / 2;
    wire [10:0] text_y0_off = 25;

    // ----------------------
    // Determine if pixel is in text region
    // ----------------------
    wire in_text_on  = (iVga_x >= text_x0_on  && iVga_x < text_x0_on  + VIDEO_ON_LEN  * CHAR_WIDTH) &&
                       (iVga_y >= text_y0_on  && iVga_y < text_y0_on  + CHAR_HEIGHT);

    wire in_text_off = (iVga_x >= text_x0_off && iVga_x < text_x0_off + VIDEO_OFF_LEN * CHAR_WIDTH) &&
                       (iVga_y >= text_y0_off && iVga_y < text_y0_off + CHAR_HEIGHT);

    // ----------------------
    // Compute character index & pixel inside character (uses new 16x32 bounds)
    // ----------------------
    // char_x_full (0 to 15)
    wire [3:0] char_x_full = (iVideo_On ? (iVga_x - text_x0_on)  : (iVga_x - text_x0_off))  % CHAR_WIDTH;
    // char_y_full (0 to 31)
    wire [4:0] char_y_full = (iVideo_On ? (iVga_y - text_y0_on)  : (iVga_y - text_y0_off))  % CHAR_HEIGHT;

    // Low-resolution 8x16 coordinates for ROM lookup (Pixel Doubling)
    // By using bits [3:1] of char_x_full, the LSB (bit 0) is ignored, doubling the width.
    wire [2:0] char_x_low = char_x_full[3:1]; // 8-pixel index (0 to 7)
    // By using bits [4:1] of char_y_full, the LSB (bit 0) is ignored, doubling the height.
    wire [3:0] char_y_low = char_y_full[4:1]; // 16-row index (0 to 15)

    // Character index is based on the 16-pixel width
    wire [2:0] char_idx = (iVideo_On ? (iVga_x - text_x0_on)  : (iVga_x - text_x0_off)) / CHAR_WIDTH;

    // ----------------------
    // Select ASCII code for current character (same logic)
    // ----------------------
    reg [6:0] ascii_code;
    always @* begin
        if(iVideo_On && in_text_on) begin
            case(char_idx)
                0: ascii_code = "I";
                1: ascii_code = "N";
                2: ascii_code = "T";
                3: ascii_code = "R";
                4: ascii_code = "U";
                5: ascii_code = "D";
                6: ascii_code = "E";
                7: ascii_code = "R";
                default: ascii_code = 7'h20;
            endcase
        end
        else if(!iVideo_On && in_text_off) begin
            case(char_idx)
                0: ascii_code = "A";
                1: ascii_code = "R";
                2: ascii_code = "M";
                3: ascii_code = "E";
                4: ascii_code = "D";
                default: ascii_code = 7'h20;
            endcase
        end
        else ascii_code = 7'h20;
    end

    // ----------------------
    // ASCII ROM address and output
    // Use the low-resolution row for addressing
    // ----------------------
    wire [10:0] rom_addr = {ascii_code, char_y_low};
    wire [7:0] rom_out;

    ascii_rom rom(
        .addr(rom_addr),
        .data(rom_out)
    );

    // rom_out[7 - char_x_low] gets the pixel state for the low-res 8x16 character.
    // This state is then used across 2x2 screen pixels.
    wire pixel_on = iVideo_On ? (in_text_on && rom_out[7 - char_x_low]) :
                                 (!iVideo_On && in_text_off && rom_out[7 - char_x_low]);

    // ----------------------
    // VGA output (remains the same)
    // ----------------------
    always @* begin
        if(pixel_on) begin
            oRed   = WHITE;
            oGreen = WHITE;
            oBlue  = WHITE;
        end
        else begin
            // NOTE: The original code outputs BLACK here, meaning the area *around* the text
            // but *inside* the text box is also BLACK. To show the original video in the
            // background, you should use:
            // oRed   = iRed;
            // oGreen = iGreen;
            // oBlue  = iBlue;
            oRed   = BLACK;
            oGreen = BLACK;
            oBlue  = BLACK;
        end
    end

endmodule
