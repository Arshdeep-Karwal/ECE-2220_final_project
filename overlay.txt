// ======================================================
//   CENTERED ASCII TEXT OVERLAY USING ascii_rom
//   Works with your exact ROM interface
//   Requires exactly 1 cycle of latency compensation
// ======================================================

module VGA_overlay (
    input         iCLK,
    input         iRST_N,
    input         iVideo_On,

    input  [10:0] iVga_x,
    input  [10:0] iVga_y,

    input  [9:0]  iRed,
    input  [9:0]  iGreen,
    input  [9:0]  iBlue,

    output reg [9:0]  oRed,
    output reg [9:0]  oGreen,
    output reg [9:0]  oBlue
);

// ---------------------------
// Text configuration
// ---------------------------
localparam CHAR_W = 8;
localparam CHAR_H = 16;

localparam LINE1_STR = "INTRUDER DETECTED";
localparam LINE2_STR = "SECURITY ALERT";

// Compute string lengths
localparam L1_LEN = 18;
localparam L2_LEN = 14;

// Center positions
localparam CENTER_X = 320 - (L1_LEN*CHAR_W)/2;
localparam CENTER_Y1 = 160;   // line 1 Y
localparam CENTER_Y2 = 200;   // line 2 Y

// ---------------------------
// ROM instance
// ---------------------------
wire [7:0] rom_data;
reg  [10:0] rom_addr_reg;
reg  [10:0] rom_addr;

ascii_rom rom_inst(
    .clk(iCLK),
    .addr(rom_addr),
    .data(rom_data)
);

// Pipeline registers for sync
reg [2:0]  col_d;
reg [10:0] x_d, y_d;
reg        text_active_d;

// ---------------------------
// Character generation
// ---------------------------
reg [7:0] current_char;
reg       text_active;

reg [3:0] row;
reg [2:0] col;

// Determine if inside line1 or line2
always @(*) begin
    text_active = 1'b0;
    current_char = 8'h20; // space

    // default row/col
    row = iVga_y[3:0];
    col = iVga_x[2:0];

    // line 1 region
    if(iVga_y >= CENTER_Y1 && iVga_y < CENTER_Y1 + CHAR_H &&
       iVga_x >= CENTER_X  && iVga_x < CENTER_X + L1_LEN*CHAR_W)
    begin
        integer idx = (iVga_x - CENTER_X) >> 3;
        text_active = 1'b1;
        current_char = LINE1_STR[(L1_LEN-1-idx)*8 +: 8];
    end

    // line 2 region
    if(iVga_y >= CENTER_Y2 && iVga_y < CENTER_Y2 + CHAR_H &&
       iVga_x >= CENTER_X  && iVga_x < CENTER_X + L2_LEN*CHAR_W)
    begin
        integer idx = (iVga_x - CENTER_X) >> 3;
        text_active = 1'b1;
        current_char = LINE2_STR[(L2_LEN-1-idx)*8 +: 8];
    end

    rom_addr = {current_char, row};
end

// ---------------------------
// Pipeline to sync ROM output
// ---------------------------
always @(posedge iCLK) begin
    if(!iRST_N) begin
        x_d <= 0;
        y_d <= 0;
        col_d <= 0;
        text_active_d <= 0;
    end else begin
        x_d <= iVga_x;
        y_d <= iVga_y;
        col_d <= col;
        text_active_d <= text_active;
    end
end

wire pixel_on = text_active_d && rom_data[7 - col_d];

// ---------------------------
// Output RGB
// ---------------------------
always @(*) begin
    if(!iVideo_On) begin
        oRed = 0;  oGreen = 0;  oBlue = 0;
    end else if(pixel_on) begin
        oRed =
